#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include "debug.h"

static const char* opcode_names[] = {
	"abort           ",
	"foreign(lll)    ",
	"foreign(llg)    ",
	"foreign(lgl)    ",
	"foreign(lgg)    ",
	"foreign(gll)    ",
	"foreign(glg)    ",
	"foreign(ggl)    ",
	"foreign(ggg)    ",

	"mov(ll)         ",
	"mov(lg)         ",
	"mov(gl)         ",
	"mov(ll)         ",
	"set(l)          ",

	"jmp             ",
	"jmpcheck(l)     ",
	"jmpcheck(g)     ",

	"call(l)         ",
	"call(g)         ",
	"return          ",
	"lbl(l)          ",
	"lbl(g)          ",
	
	"ldalloc(lll)    ",
	"ldalloc(llg)    ",
	"ldalloc(lgl)    ",
	"ldalloc(lgg)    ",
	"ldalloc(gll)    ",
	"ldalloc(glg)    ",
	"ldalloc(ggl)    ",
	"ldalloc(ggg)    ",
	"ldalloc_i(ll)   ",
	"ldalloc_i(lg)   ",
	"ldalloc_i(gl)   ",
	"ldalloc_i(gg)   ",
	"ldalloc_ib(ll)  ",
	"ldalloc_ib(ll)  ",
	"ldalloc_ib(ll)  ",
	"ldalloc_ib(ll)  ",
	"stoalloc(llg)   ",
	"stoalloc(lgl)   ",
	"stoalloc(lgg)   ",
	"stoalloc(gll)   ",
	"stoalloc(gll)   ",
	"stoalloc(glg)   ",
	"stoalloc(ggl)   ",
	"stoalloc(ggg)   ",
	"stoalloc_i(ll)  ",
	"stoalloc_i(lg)  ",
	"stoalloc_i(gl)  ",
	"stoalloc_i(gg)  ",
	"stoalloc_ib(ll) ",
	"stoalloc_ib(lg) ",
	"stoalloc_ib(gl) ",
	"stoalloc_ib(gg) ",
	"conft_i(l)      ",
	"conft_i(g)      ",
	"dynconft_i(ll)  ",
	"dynconft(ll)    ",
	
	"offset          ",
	"deoffset        ",

	"alloc(ll)       ",
	"alloc(lg)       ",
	"alloc(gl)       ",
	"alloc(gg)       ",
	"alloc_i(l)      ",
	"alloc_i(g)      ",
	"free(l)         ",
	"free(g)         ",
	"dynfree(ll)     ",

	"newframe        ",
	"gctrace(l)      ",
	"gctrace(g)      ",
	"dyntrace(ll)    ",
	"gcclean         ",

	"and(lll)        ",
	"and(llg)        ",
	"and(lgl)        ",
	"and(lgg)        ",
	"and(gll)        ",
	"and(glg)        ",
	"and(ggl)        ",
	"and(ggg)        ",
	"or(lll)         ",
	"or(llg)         ",
	"or(lgl)         ",
	"or(lgg)         ",
	"or(gll)         ",
	"or(glg)         ",
	"or(ggl)         ",
	"or(ggg)         ",
	"not(ll)         ",
	"not(lg)         ",
	"not(gl)         ",
	"not(gg)         ",
	"len(ll)         ",
	"len(lg)         ",
	"len(gl)         ",
	"len(gg)         ",

	"bequal(lll)     ",
	"bequal(llg)     ",
	"bequal(lgl)     ",
	"bequal(lgg)     ",
	"bequal(gll)     ",
	"bequal(glg)     ",
	"bequal(ggl)     ",
	"bequal(ggg)     ",
	"cequal(lll)     ",
	"cequal(llg)     ",
	"cequal(lgl)     ",
	"cequal(lgg)     ",
	"cequal(gll)     ",
	"cequal(glg)     ",
	"cequal(ggl)     ",
	"cequal(ggg)     ",
	"lequal(lll)     ",
	"lequal(llg)     ",
	"lequal(lgl)     ",
	"lequal(lgg)     ",
	"lequal(gll)     ",
	"lequal(glg)     ",
	"lequal(ggl)     ",
	"lequal(ggg)     ",
	"fequal(lll)     ",
	"fequal(llg)     ",
	"fequal(lgl)     ",
	"fequal(lgg)     ",
	"fequal(gll)     ",
	"fequal(glg)     ",
	"fequal(ggl)     ",
	"fequal(ggg)     ",
	
	"lmore(lll)      ",
	"lmore(llg)      ",
	"lmore(lgl)      ",
	"lmore(lgg)      ",
	"lmore(gll)      ",
	"lmore(glg)      ",
	"lmore(ggl)      ",
	"lmore(ggg)      ",
	"lless(lll)      ",
	"lless(llg)      ",
	"lless(lgl)      ",
	"lless(lgg)      ",
	"lless(gll)      ",
	"lless(glg)      ",
	"lless(ggl)      ",
	"lless(ggg)      ",
	"lmoreeq(lll)    ",
	"lmoreeq(llg)    ",
	"lmoreeq(lgl)    ",
	"lmoreeq(lgg)    ",
	"lmoreeq(gll)    ",
	"lmoreeq(glg)    ",
	"lmoreeq(ggl)    ",
	"lmoreeq(ggg)    ",
	"llesseq(lll)    ",
	"llesseq(llg)    ",
	"llesseq(lgl)    ",
	"llesseq(lgg)    ",
	"llesseq(gll)    ",
	"llesseq(glg)    ",
	"llesseq(ggl)    ",
	"llesseq(ggg)    ",

	"ladd(lll)       ",
	"ladd(llg)       ",
	"ladd(lgl)       ",
	"ladd(lgg)       ",
	"ladd(gll)       ",
	"ladd(glg)       ",
	"ladd(ggl)       ",
	"ladd(ggg)       ",
	"lsub(lll)       ",
	"lsub(llg)       ",
	"lsub(lgl)       ",
	"lsub(lgg)       ",
	"lsub(gll)       ",
	"lsub(glg)       ",
	"lsub(ggl)       ",
	"lsub(ggg)       ",
	"lmul(lll)       ",
	"lmul(llg)       ",
	"lmul(lgl)       ",
	"lmul(lgg)       ",
	"lmul(gll)       ",
	"lmul(glg)       ",
	"lmul(ggl)       ",
	"lmul(ggg)       ",
	"ldiv(lll)       ",
	"ldiv(llg)       ",
	"ldiv(lgl)       ",
	"ldiv(lgg)       ",
	"ldiv(gll)       ",
	"ldiv(glg)       ",
	"ldiv(ggl)       ",
	"ldiv(ggg)       ",
	"lmod(lll)       ",
	"lmod(llg)       ",
	"lmod(lgl)       ",
	"lmod(lgg)       ",
	"lmod(gll)       ",
	"lmod(glg)       ",
	"lmod(ggl)       ",
	"lmod(ggg)       ",
	"lpow(lll)       ",
	"lpow(llg)       ",
	"lpow(lgl)       ",
	"lpow(lgg)       ",
	"lpow(gll)       ",
	"lpow(glg)       ",
	"lpow(ggl)       ",
	"lpow(ggg)       ",

	"fmore(lll)      ",
	"fmore(llg)      ",
	"fmore(lgl)      ",
	"fmore(lgg)      ",
	"fmore(gll)      ",
	"fmore(glg)      ",
	"fmore(ggl)      ",
	"fmore(ggg)      ",
	"fless(lll)      ",
	"fless(llg)      ",
	"fless(lgl)      ",
	"fless(lgg)      ",
	"fless(gll)      ",
	"fless(glg)      ",
	"fless(ggl)      ",
	"fless(ggg)      ",
	"fmoreeq(lll)    ",
	"fmoreeq(llg)    ",
	"fmoreeq(lgl)    ",
	"fmoreeq(lgg)    ",
	"fmoreeq(gll)    ",
	"fmoreeq(glg)    ",
	"fmoreeq(ggl)    ",
	"fmoreeq(ggg)    ",
	"flesseq(lll)    ",
	"flesseq(llg)    ",
	"flesseq(lgl)    ",
	"flesseq(lgg)    ",
	"flesseq(gll)    ",
	"flesseq(glg)    ",
	"flesseq(ggl)    ",
	"flesseq(ggg)    ",

	
	"fadd(lll)       ",
	"fadd(llg)       ",
	"fadd(lgl)       ",
	"fadd(lgg)       ",
	"fadd(gll)       ",
	"fadd(glg)       ",
	"fadd(ggl)       ",
	"fadd(ggg)       ",
	"fsub(lll)       ",
	"fsub(llg)       ",
	"fsub(lgl)       ",
	"fsub(lgg)       ",
	"fsub(gll)       ",
	"fsub(glg)       ",
	"fsub(ggl)       ",
	"fsub(ggg)       ",
	"fmul(lll)       ",
	"fmul(llg)       ",
	"fmul(lgl)       ",
	"fmul(lgg)       ",
	"fmul(gll)       ",
	"fmul(glg)       ",
	"fmul(ggl)       ",
	"fmul(ggg)       ",
	"fdiv(lll)       ",
	"fdiv(llg)       ",
	"fdiv(lgl)       ",
	"fdiv(lgg)       ",
	"fdiv(gll)       ",
	"fdiv(glg)       ",
	"fdiv(ggl)       ",
	"fdiv(ggg)       ",
	"fmod(lll)       ",
	"fmod(llg)       ",
	"fmod(lgl)       ",
	"fmod(lgg)       ",
	"fmod(gll)       ",
	"fmod(glg)       ",
	"fmod(ggl)       ",
	"fmod(ggg)       ",
	"fpow(lll)       ",
	"fpow(llg)       ",
	"fpow(lgl)       ",
	"fpow(lgg)       ",
	"fpow(gll)       ",
	"fpow(glg)       ",
	"fpow(ggl)       ",
	"fpow(ggg)       ",

	"fneg(gl)        ",
	"fneg(lg)        ",
	"fneg(gl)        ",
	"fneg(gg)        ",
	"lneg(gl)        ",
	"lneg(lg)        ",
	"lneg(gl)        ",
	"lneg(gg)        ",
};

static const char* error_names[] = {
	"none",
	"memory",
	"internal",

	"unexpected token",

	"cannot set readonly var",
	"unallowed type",

	"expected sub types",

	"undeclared",
	"redeclaration",

	"unexpected type",
	"unexpected argument length",

	"cannot return",
	"cannot break",
	"cannot continue",

	"index out of range",
	"divide by zero",
	"stack overflow",
	"read unitialized memory",

	"function unable to return",
	
	"program aborted",
	"foreign error",
	"cannot open file"
};

void print_instructions(machine_ins_t* ins, uint16_t ins_count) {
	for (uint16_t i = 0; i < ins_count; i++)
		printf("%"PRIu16 ":\t%s\t%" PRIu16 "\t%" PRIu16 "\t%" PRIu16 "\n", i, opcode_names[ins[i].op_code], ins[i].a, ins[i].b, ins[i].c);
}

const char* get_err_msg(error_t error) {
	return error_names[error];
}

void print_error_trace(multi_scanner_t multi_scanner) {
	for (uint_fast8_t i = 0; i < multi_scanner.current_file; i++)
		printf("in %s: row %" PRIu32 ", col %"PRIu32 "\n", multi_scanner.file_paths[i], multi_scanner.scanners[i].row, multi_scanner.scanners[i].col);
	printf("\t");
	for (uint_fast32_t i = 0; i < multi_scanner.last_tok.length; i++)
		printf("%c", multi_scanner.last_tok.str[i]);
	for(uint_fast8_t i = multi_scanner.last_tok.length; multi_scanner.last_tok.str[i] && multi_scanner.last_tok.str[i] == '\n'; i++)
		printf("%c", multi_scanner.last_tok.str[i]);
	printf("\n");
}
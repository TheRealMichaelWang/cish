include "io.txt";
include "std.txt";
include "string.txt";

record matrix {
	array<float> innerArray;
	int rows;
	int cols;
}

record point {
	float x;
	float y;
}

global readonly auto makeMat = proc (int rows, int cols) return matrix {
	return new matrix {
		rows = rows;
		cols = cols;
		innerArray = new float[rows * cols];
	};
};

global readonly auto matFrom2DArray = proc(array<array<float>> arr) return matrix {
	matrix mymat = new matrix {
		rows = #arr;
		cols = #arr[0];
		innerArray = new float[#arr * #arr[0]];
	};
	int r = 0;
	while(r < mymat.rows) {
		int c = 0;
		while(c < mymat.cols) {
			mymat.innerArray[r * mymat.cols + c] = arr[r][c];
			c = c + 1;
		}
		r = r + 1;
	}
	return mymat;
};

global readonly auto idMat = proc(int dim) return matrix {
	matrix res = new matrix {
		rows = dim;
		cols = dim;
		innerArray = new float[dim * dim];
	};
	int i = 0;
	while(i < #res.innerArray) {
		res.innerArray[i] = 0f;
		i = i + 1;
	}
	i = 0;
	while(i < dim) {
		res.innerArray[i * dim + i] = 1f;
		i = i + 1;
	}
	return res;
};

global readonly auto printMat = proc(matrix mat) return nothing {
	int i = 0;
	while(i < #mat.innerArray) {
		if(i > 0 and i % mat.cols == 0) {
			put_char('\n');
		}
		print(ftos(mat.innerArray[i]));
		put_char(' ');
		i = i + 1;
	}
	return;
};

global readonly auto matMul = proc(matrix a, matrix b) return matrix {
	if(a.cols != b.rows) {
		abort; 
	}
	
	matrix prod = new matrix {
		rows = a.rows;
		cols = b.cols;
		innerArray = new float[a.rows * b.cols];
	};

	readonly auto mulRowCol = proc(matrix a, matrix b, int aRow, int bCol) return float {
		float sum = 0f;
		int i = 0;
		while(i < a.cols) {
			sum = sum + a.innerArray[aRow * a.cols + i] * b.innerArray[i * b.cols + bCol];
			i = i + 1;
		}
		return sum;
	};

	int r = 0;
	while(r < prod.rows) {
		int c = 0;
		while(c < prod.cols) {
			prod.innerArray[r * prod.cols + c] = mulRowCol(a, b, r, c);
			c = c + 1;
		}
		r = r + 1;
	}
	return prod;
};

global readonly auto transPoly = proc(matrix trans, array<point> polygon) return array<point> {
	readonly auto pointToMat = proc(point pt) return matrix {
		return new matrix {
			rows = 2;
			cols = 1;
			innerArray = [pt.x, pt.y];
		};
	};

	readonly auto matToPoint = proc(matrix mat) return point {
		if(mat.rows != 2 or mat.cols != 1) {
			abort;
		}
		return new point {
			x = mat.innerArray[0];
			y = mat.innerArray[1];
		};
	};

	int i = 0;
	while(i < #polygon) {
		polygon[i] = matToPoint(matMul(trans, pointToMat(polygon[i])));
		i = i + 1;
	}
	return polygon;
};

global readonly auto printPoly = proc(array<point> polygon) return nothing {
	readonly auto printPoint = proc (point pt) return nothing {
		print("X: ");
		print(ftos(pt.x));
		print("\tY: ");
		print(ftos(pt.y));
		return;
	};

	int i = 0;
	while(i < #polygon) {
		print(itos(i));
		print(")\t");
		printPoint(polygon[i]);
		put_char('\n');
		i = i + 1;
	}
	return;
};

global readonly auto getPolyArea = proc(array<point> polygon) return float {
	float area = 0f;

	int i = 0;
	int j = #polygon - 1;
	while(i < #polygon) {
		area = area + 
			(polygon[i].x + polygon[j].x) * (polygon[j].y - polygon[i].y);
		j = i;
		i = i + 1;
	}

	return fabs(area / 2f);
};

global readonly auto makeSquare = proc(point pt, float width) return array<point> {
	return [
		pt,
		new point {x = pt.x + width; y = pt.y;},
		new point {x = pt.x + width; y = pt.y + width;},
		new point {x = pt.x; y = pt.y + width;}
	];
};

global readonly point origin = new point {
	x = 0f;
	y = 0f;
};

matrix trans = matFrom2DArray(
	[[5f, 1f],
	 [10f, 2f]]);
array<point> poly = makeSquare(origin, 1f);

printPoly(poly);
transPoly(trans, poly);
put_char('\n');
printPoly(poly);